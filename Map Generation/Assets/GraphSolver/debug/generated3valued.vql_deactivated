import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}
pattern mustEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mustExist(problem,interpretation,a);
	find mustExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Terrain class".
 */
private pattern mustInstanceOfTerrain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Terrain class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTerrain_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Terrain class");
}

/**
 * An element may be an instance of type "Terrain class".
 */
private pattern mayInstanceOfTerrain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find mustInstanceOfWater_class(problem,interpretation,element);
	neg find scopeDisallowsNewTerrain_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find mustInstanceOfWater_class(problem,interpretation,element);
	neg find scopeDisallowsNewTerrain_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTerrain_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Water class".
 */
private pattern mustInstanceOfWater_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Water class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewWater_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Water class");
}

/**
 * An element may be an instance of type "Water class".
 */
private pattern mayInstanceOfWater_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTerrain_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find scopeDisallowsNewWater_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTerrain_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find scopeDisallowsNewWater_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfWater_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Map class".
 */
private pattern mustInstanceOfMap_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Map class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMap_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Map class");
}

/**
 * An element may be an instance of type "Map class".
 */
private pattern mayInstanceOfMap_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find mustInstanceOfGridType_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewMap_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find mustInstanceOfGridType_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewMap_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMap_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Grid class".
 */
private pattern mustInstanceOfGrid_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Grid class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewGrid_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Grid class");
}

/**
 * An element may be an instance of type "Grid class".
 */
private pattern mayInstanceOfGrid_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfGridType_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewGrid_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfGridType_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewGrid_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfGrid_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "GridType class".
 */
private pattern mustInstanceOfGridType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"GridType class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewGridType_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"GridType class");
}

/**
 * An element may be an instance of type "GridType class".
 */
private pattern mayInstanceOfGridType_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfTerrain_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find mustInstanceOfWater_class(problem,interpretation,element);
	neg find scopeDisallowsNewGridType_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfTerrain_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find mustInstanceOfWater_class(problem,interpretation,element);
	neg find scopeDisallowsNewGridType_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfGridType_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Map class DefinedPart".
 */
private pattern mustInstanceOfMap_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Map class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMap_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Map class DefinedPart");
}

/**
 * An element may be an instance of type "Map class DefinedPart".
 */
private pattern mayInstanceOfMap_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMap_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Map class UndefinedPart".
 */
private pattern mustInstanceOfMap_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Map class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMap_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Map class UndefinedPart");
}

/**
 * An element may be an instance of type "Map class UndefinedPart".
 */
private pattern mayInstanceOfMap_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfGridType_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find scopeDisallowsNewMap_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfGridType_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find scopeDisallowsNewMap_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMap_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Grid class DefinedPart".
 */
private pattern mustInstanceOfGrid_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Grid class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewGrid_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Grid class DefinedPart");
}

/**
 * An element may be an instance of type "Grid class DefinedPart".
 */
private pattern mayInstanceOfGrid_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfGrid_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Grid class UndefinedPart".
 */
private pattern mustInstanceOfGrid_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Grid class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewGrid_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Grid class UndefinedPart");
}

/**
 * An element may be an instance of type "Grid class UndefinedPart".
 */
private pattern mayInstanceOfGrid_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfGridType_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find scopeDisallowsNewGrid_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfGridType_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find scopeDisallowsNewGrid_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfGrid_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []grids reference Map(source,target)
 */
private pattern mustInRelationgrids_reference_Map(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"grids reference Map");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>grids reference Map(source,target)
 */
private pattern mayInRelationgrids_reference_Map(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMap_class(problem,interpretation,source);
	find mayInstanceOfGrid_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationgrids_reference_Map(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []left reference Grid(source,target)
 */
private pattern mustInRelationleft_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"left reference Grid");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>left reference Grid(source,target)
 */
private pattern mayInRelationleft_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfGrid_class(problem,interpretation,source);
	find mayInstanceOfGrid_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationleft_reference_Grid(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationright_reference_Grid(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationleft_reference_Grid(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []right reference Grid(source,target)
 */
private pattern mustInRelationright_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"right reference Grid");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>right reference Grid(source,target)
 */
private pattern mayInRelationright_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfGrid_class(problem,interpretation,source);
	find mayInstanceOfGrid_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationright_reference_Grid(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationleft_reference_Grid(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationright_reference_Grid(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []up reference Grid(source,target)
 */
private pattern mustInRelationup_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"up reference Grid");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>up reference Grid(source,target)
 */
private pattern mayInRelationup_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfGrid_class(problem,interpretation,source);
	find mayInstanceOfGrid_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationup_reference_Grid(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationdown_reference_Grid(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationup_reference_Grid(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []down reference Grid(source,target)
 */
private pattern mustInRelationdown_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"down reference Grid");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>down reference Grid(source,target)
 */
private pattern mayInRelationdown_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfGrid_class(problem,interpretation,source);
	find mayInstanceOfGrid_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdown_reference_Grid(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationup_reference_Grid(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationdown_reference_Grid(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []types reference Grid(source,target)
 */
private pattern mustInRelationtypes_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"types reference Grid");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>types reference Grid(source,target)
 */
private pattern mayInRelationtypes_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfGrid_class(problem,interpretation,source);
	find mayInstanceOfGridType_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtypes_reference_Grid(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationgrid_reference_GridType(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationtypes_reference_Grid(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []grid reference GridType(source,target)
 */
private pattern mustInRelationgrid_reference_GridType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"grid reference GridType");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>grid reference GridType(source,target)
 */
private pattern mayInRelationgrid_reference_GridType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfGridType_class(problem,interpretation,source);
	find mayInstanceOfGrid_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationgrid_reference_GridType(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtypes_reference_Grid(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationgrid_reference_GridType(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []id attribute Grid(source,target)
 */
private pattern mustInRelationid_attribute_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id attribute Grid");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>id attribute Grid(source,target)
 */
private pattern mayInRelationid_attribute_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfGrid_class(problem,interpretation,source);
	IntegerElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationid_attribute_Grid(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationid_attribute_Grid(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern queries haveReference
private pattern mustInRelation_pattern_queries_haveReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a, var_t)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfGrid_class(problem,interpretation,var_a);
	find mustInstanceOfGridType_class(problem,interpretation,var_t);
	// a is exported
	// t is exported
	find mustInstanceOfGrid_class(problem,interpretation,var_a);
	find mustInRelationtypes_reference_Grid(problem,interpretation,var_a,var_virtual0);
	find mustInstanceOfGridType_class(problem,interpretation,var_virtual0);
	find mustEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern mayInRelation_pattern_queries_haveReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a, var_t)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfGrid_class(problem,interpretation,var_a);
	find mayInstanceOfGridType_class(problem,interpretation,var_t);
	// a is exported
	// t is exported
	find mayInstanceOfGrid_class(problem,interpretation,var_a);
	find mayInRelationtypes_reference_Grid(problem,interpretation,var_a,var_virtual0);
	find mayInstanceOfGridType_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_t);
}
private pattern currentInRelation_pattern_queries_haveReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a, var_t)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfGrid_class(problem,interpretation,var_a);
	find mustInstanceOfGridType_class(problem,interpretation,var_t);
	// a is exported
	// t is exported
	find mustInstanceOfGrid_class(problem,interpretation,var_a);
	find mustInRelationtypes_reference_Grid(problem,interpretation,var_a,var_virtual0);
	find mustInstanceOfGridType_class(problem,interpretation,var_virtual0);
	find mustEquivalent(problem, interpretation, var_virtual0, var_t);
}
// Must, May and Current queries for pattern queries noReference
private pattern mustInRelation_pattern_queries_noReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfGrid_class(problem,interpretation,var_a);
	// a is exported
	neg find mayInRelation_pattern_queries_haveReference(problem,interpretation,var_a,_var__0);
}
private pattern mayInRelation_pattern_queries_noReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfGrid_class(problem,interpretation,var_a);
	// a is exported
	neg find mustInRelation_pattern_queries_haveReference(problem,interpretation,var_a,_var__0);
}
private pattern currentInRelation_pattern_queries_noReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfGrid_class(problem,interpretation,var_a);
	// a is exported
	neg find currentInRelation_pattern_queries_haveReference(problem,interpretation,var_a,_var__0);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationgrids_reference_Map(problem,interpretation,source,target); }or
	
	{ find mustInRelationtypes_reference_Grid(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_queries_noReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find mustInRelation_pattern_queries_noReference(problem,interpretation,var_a);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_queries_noReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find currentInRelation_pattern_queries_noReference(problem,interpretation,var_a);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMap_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTerrain_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfGrid_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfWater_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfGridType_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMap_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMap_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfGrid_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfGrid_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Terrain_class_by_types_reference_Grid_with_grid_reference_GridType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Terrain class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"types reference Grid");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"grid reference GridType");
	find mustInstanceOfGrid_class(problem,interpretation,container);
	find mayInstanceOfTerrain_class(problem,interpretation,newObject);
	find mayInRelationtypes_reference_Grid(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Terrain_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Terrain class");
	find mayInstanceOfTerrain_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Map_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Map class UndefinedPart");
	find mayInstanceOfMap_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Grid_class_UndefinedPart_by_grids_reference_Map(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Grid class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"grids reference Map");
	find mustInstanceOfMap_class(problem,interpretation,container);
	find mayInstanceOfGrid_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationgrids_reference_Map(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Grid_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Grid class UndefinedPart");
	find mayInstanceOfGrid_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Water_class_by_types_reference_Grid_with_grid_reference_GridType(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Water class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"types reference Grid");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"grid reference GridType");
	find mustInstanceOfGrid_class(problem,interpretation,container);
	find mayInstanceOfWater_class(problem,interpretation,newObject);
	find mayInRelationtypes_reference_Grid(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Water_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Water class");
	find mayInstanceOfWater_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Terrain_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTerrain_class(problem,interpretation,element);
	neg find mustInstanceOfTerrain_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find mustInstanceOfWater_class(problem,interpretation,element);
}
pattern refineTypeTo_Map_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMap_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfGridType_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_Grid_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfGrid_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfGridType_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_Water_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfWater_class(problem,interpretation,element);
	neg find mustInstanceOfTerrain_class(problem,interpretation,element);
	neg find mustInstanceOfGrid_class(problem,interpretation,element);
	neg find mustInstanceOfMap_class(problem,interpretation,element);
	neg find mustInstanceOfWater_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_left_reference_Grid_and_right_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"left reference Grid");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"right reference Grid");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfGrid_class(problem,interpretation,from);
	find mustInstanceOfGrid_class(problem,interpretation,to);
	find mayInRelationleft_reference_Grid(problem,interpretation,from,to);
	neg find mustInRelationleft_reference_Grid(problem,interpretation,from,to);
}
pattern refineRelation_down_reference_Grid_and_up_reference_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"down reference Grid");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"up reference Grid");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfGrid_class(problem,interpretation,from);
	find mustInstanceOfGrid_class(problem,interpretation,to);
	find mayInRelationdown_reference_Grid(problem,interpretation,from,to);
	neg find mustInRelationdown_reference_Grid(problem,interpretation,from,to);
}
pattern refineRelation_id_attribute_Grid(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"id attribute Grid");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfGrid_class(problem,interpretation,from);
	IntegerElement(to);
	find mayInRelationid_attribute_Grid(problem,interpretation,from,to);
	neg find mustInRelationid_attribute_Grid(problem,interpretation,from,to);
}

