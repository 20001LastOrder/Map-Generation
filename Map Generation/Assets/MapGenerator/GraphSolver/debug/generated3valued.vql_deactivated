import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}
pattern mustEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mustExist(problem,interpretation,a);
	find mustExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Island class".
 */
private pattern mustInstanceOfIsland_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Island class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewIsland_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Island class");
}

/**
 * An element may be an instance of type "Island class".
 */
private pattern mayInstanceOfIsland_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfSea_class(problem,interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfContinent_class(problem,interpretation,element);
	neg find scopeDisallowsNewIsland_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfSea_class(problem,interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfContinent_class(problem,interpretation,element);
	neg find scopeDisallowsNewIsland_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfIsland_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Sea class".
 */
private pattern mustInstanceOfSea_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Sea class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSea_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Sea class");
}

/**
 * An element may be an instance of type "Sea class".
 */
private pattern mayInstanceOfSea_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegion_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewSea_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegion_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewSea_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSea_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Continent class".
 */
private pattern mustInstanceOfContinent_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Continent class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewContinent_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Continent class");
}

/**
 * An element may be an instance of type "Continent class".
 */
private pattern mayInstanceOfContinent_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfSea_class(problem,interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfIsland_class(problem,interpretation,element);
	neg find scopeDisallowsNewContinent_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfSea_class(problem,interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfIsland_class(problem,interpretation,element);
	neg find scopeDisallowsNewContinent_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfContinent_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Lake class".
 */
private pattern mustInstanceOfLake_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Lake class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLake_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Lake class");
}

/**
 * An element may be an instance of type "Lake class".
 */
private pattern mayInstanceOfLake_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMountain_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCity_class(problem,interpretation,element);
	neg find scopeDisallowsNewLake_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMountain_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCity_class(problem,interpretation,element);
	neg find scopeDisallowsNewLake_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLake_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Mountain class".
 */
private pattern mustInstanceOfMountain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Mountain class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMountain_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Mountain class");
}

/**
 * An element may be an instance of type "Mountain class".
 */
private pattern mayInstanceOfMountain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfLake_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCity_class(problem,interpretation,element);
	neg find scopeDisallowsNewMountain_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfLake_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCity_class(problem,interpretation,element);
	neg find scopeDisallowsNewMountain_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMountain_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "City class".
 */
private pattern mustInstanceOfCity_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"City class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCity_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"City class");
}

/**
 * An element may be an instance of type "City class".
 */
private pattern mayInstanceOfCity_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfLake_class(problem,interpretation,element);
	neg find mustInstanceOfMountain_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewCity_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfLake_class(problem,interpretation,element);
	neg find mustInstanceOfMountain_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewCity_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCity_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Region class".
 */
private pattern mustInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Region class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegion_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Region class");
}

/**
 * An element may be an instance of type "Region class".
 */
private pattern mayInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegion_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ElementaryRegion class".
 */
private pattern mustInstanceOfElementaryRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ElementaryRegion class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewElementaryRegion_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ElementaryRegion class");
}

/**
 * An element may be an instance of type "ElementaryRegion class".
 */
private pattern mayInstanceOfElementaryRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfLake_class(problem,interpretation,element);
	neg find mustInstanceOfMountain_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCity_class(problem,interpretation,element);
	neg find scopeDisallowsNewElementaryRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfLake_class(problem,interpretation,element);
	neg find mustInstanceOfMountain_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCity_class(problem,interpretation,element);
	neg find scopeDisallowsNewElementaryRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfElementaryRegion_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeRegion class".
 */
private pattern mustInstanceOfCompositeRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeRegion class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeRegion_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeRegion class");
}

/**
 * An element may be an instance of type "CompositeRegion class".
 */
private pattern mayInstanceOfCompositeRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfSea_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfSea_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeRegion_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Sea class DefinedPart".
 */
private pattern mustInstanceOfSea_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Sea class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSea_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Sea class DefinedPart");
}

/**
 * An element may be an instance of type "Sea class DefinedPart".
 */
private pattern mayInstanceOfSea_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSea_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Sea class UndefinedPart".
 */
private pattern mustInstanceOfSea_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Sea class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSea_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Sea class UndefinedPart");
}

/**
 * An element may be an instance of type "Sea class UndefinedPart".
 */
private pattern mayInstanceOfSea_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfContinent_class(problem,interpretation,element);
	neg find mustInstanceOfIsland_class(problem,interpretation,element);
	neg find scopeDisallowsNewSea_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfContinent_class(problem,interpretation,element);
	neg find mustInstanceOfIsland_class(problem,interpretation,element);
	neg find scopeDisallowsNewSea_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSea_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Region class DefinedPart".
 */
private pattern mustInstanceOfRegion_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Region class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegion_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Region class DefinedPart");
}

/**
 * An element may be an instance of type "Region class DefinedPart".
 */
private pattern mayInstanceOfRegion_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRegion_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Region class UndefinedPart".
 */
private pattern mustInstanceOfRegion_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Region class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegion_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Region class UndefinedPart");
}

/**
 * An element may be an instance of type "Region class UndefinedPart".
 */
private pattern mayInstanceOfRegion_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegion_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeRegion class DefinedPart".
 */
private pattern mustInstanceOfCompositeRegion_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeRegion class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeRegion_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeRegion class DefinedPart");
}

/**
 * An element may be an instance of type "CompositeRegion class DefinedPart".
 */
private pattern mayInstanceOfCompositeRegion_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfCompositeRegion_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeRegion class UndefinedPart".
 */
private pattern mustInstanceOfCompositeRegion_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeRegion class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeRegion_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeRegion class UndefinedPart");
}

/**
 * An element may be an instance of type "CompositeRegion class UndefinedPart".
 */
private pattern mayInstanceOfCompositeRegion_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfSea_class(problem,interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfContinent_class(problem,interpretation,element);
	neg find mustInstanceOfIsland_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeRegion_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfSea_class(problem,interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfContinent_class(problem,interpretation,element);
	neg find mustInstanceOfIsland_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeRegion_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeRegion_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []next reference Region(source,target)
 */
private pattern mustInRelationnext_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"next reference Region");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>next reference Region(source,target)
 */
private pattern mayInRelationnext_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRegion_class(problem,interpretation,source);
	find mayInstanceOfRegion_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnext_reference_Region(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationnext_reference_Region(problem,interpretation,target,_);
	check(numberOfExistingOppositeReferences < 1);
} or {
	find mustInRelationnext_reference_Region(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []insides reference CompositeRegion(source,target)
 */
private pattern mustInRelationinsides_reference_CompositeRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"insides reference CompositeRegion");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>insides reference CompositeRegion(source,target)
 */
private pattern mayInRelationinsides_reference_CompositeRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCompositeRegion_class(problem,interpretation,source);
	find mayInstanceOfRegion_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationinsides_reference_CompositeRegion(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern queries isIsland
private pattern mustInRelation_pattern_queries_isIsland(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfIsland_class(problem,interpretation,var_a);
}
private pattern mayInRelation_pattern_queries_isIsland(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mayInstanceOfIsland_class(problem,interpretation,var_a);
}
private pattern currentInRelation_pattern_queries_isIsland(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfIsland_class(problem,interpretation,var_a);
}
// Must, May and Current queries for pattern queries isSea
private pattern mustInRelation_pattern_queries_isSea(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfSea_class(problem,interpretation,var_a);
}
private pattern mayInRelation_pattern_queries_isSea(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mayInstanceOfSea_class(problem,interpretation,var_a);
}
private pattern currentInRelation_pattern_queries_isSea(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfSea_class(problem,interpretation,var_a);
}
// Must, May and Current queries for pattern queries isContinent
private pattern mustInRelation_pattern_queries_isContinent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfContinent_class(problem,interpretation,var_a);
}
private pattern mayInRelation_pattern_queries_isContinent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mayInstanceOfContinent_class(problem,interpretation,var_a);
}
private pattern currentInRelation_pattern_queries_isContinent(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfContinent_class(problem,interpretation,var_a);
}
// Must, May and Current queries for pattern queries isLake
private pattern mustInRelation_pattern_queries_isLake(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfLake_class(problem,interpretation,var_a);
}
private pattern mayInRelation_pattern_queries_isLake(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mayInstanceOfLake_class(problem,interpretation,var_a);
}
private pattern currentInRelation_pattern_queries_isLake(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfLake_class(problem,interpretation,var_a);
}
// Must, May and Current queries for pattern queries isMountain
private pattern mustInRelation_pattern_queries_isMountain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfMountain_class(problem,interpretation,var_a);
}
private pattern mayInRelation_pattern_queries_isMountain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mayInstanceOfMountain_class(problem,interpretation,var_a);
}
private pattern currentInRelation_pattern_queries_isMountain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfMountain_class(problem,interpretation,var_a);
}
// Must, May and Current queries for pattern queries isCity
private pattern mustInRelation_pattern_queries_isCity(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfCity_class(problem,interpretation,var_a);
}
private pattern mayInRelation_pattern_queries_isCity(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mayInstanceOfCity_class(problem,interpretation,var_a);
}
private pattern currentInRelation_pattern_queries_isCity(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfCity_class(problem,interpretation,var_a);
}
// Must, May and Current queries for pattern queries IslandInside
private pattern mustInRelation_pattern_queries_IslandInside(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfIsland_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfIsland_class(problem,interpretation,var_a);
	find mustInRelationinsides_reference_CompositeRegion(problem,interpretation,var_a,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustEquivalent(problem, interpretation, var_virtual0, var_b);
	neg find mayInRelation_pattern_queries_isLake(problem,interpretation,var_b);
	neg find mayInRelation_pattern_queries_isMountain(problem,interpretation,var_b);
	neg find mayInRelation_pattern_queries_isCity(problem,interpretation,var_b);
}
private pattern mayInRelation_pattern_queries_IslandInside(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfIsland_class(problem,interpretation,var_a);
	// a is exported
	find mayInstanceOfIsland_class(problem,interpretation,var_a);
	find mayInRelationinsides_reference_CompositeRegion(problem,interpretation,var_a,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_b);
	neg find mustInRelation_pattern_queries_isLake(problem,interpretation,var_b);
	neg find mustInRelation_pattern_queries_isMountain(problem,interpretation,var_b);
	neg find mustInRelation_pattern_queries_isCity(problem,interpretation,var_b);
}
private pattern currentInRelation_pattern_queries_IslandInside(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfIsland_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfIsland_class(problem,interpretation,var_a);
	find mustInRelationinsides_reference_CompositeRegion(problem,interpretation,var_a,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustEquivalent(problem, interpretation, var_virtual0, var_b);
	neg find currentInRelation_pattern_queries_isLake(problem,interpretation,var_b);
	neg find currentInRelation_pattern_queries_isMountain(problem,interpretation,var_b);
	neg find currentInRelation_pattern_queries_isCity(problem,interpretation,var_b);
}
// Must, May and Current queries for pattern queries SeaInside
private pattern mustInRelation_pattern_queries_SeaInside(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSea_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfSea_class(problem,interpretation,var_a);
	find mustInRelationinsides_reference_CompositeRegion(problem,interpretation,var_a,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustEquivalent(problem, interpretation, var_virtual0, var_b);
	neg find mayInRelation_pattern_queries_isIsland(problem,interpretation,var_b);
	neg find mayInRelation_pattern_queries_isContinent(problem,interpretation,var_b);
}
private pattern mayInRelation_pattern_queries_SeaInside(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfSea_class(problem,interpretation,var_a);
	// a is exported
	find mayInstanceOfSea_class(problem,interpretation,var_a);
	find mayInRelationinsides_reference_CompositeRegion(problem,interpretation,var_a,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_b);
	neg find mustInRelation_pattern_queries_isIsland(problem,interpretation,var_b);
	neg find mustInRelation_pattern_queries_isContinent(problem,interpretation,var_b);
}
private pattern currentInRelation_pattern_queries_SeaInside(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfSea_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfSea_class(problem,interpretation,var_a);
	find mustInRelationinsides_reference_CompositeRegion(problem,interpretation,var_a,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustEquivalent(problem, interpretation, var_virtual0, var_b);
	neg find currentInRelation_pattern_queries_isIsland(problem,interpretation,var_b);
	neg find currentInRelation_pattern_queries_isContinent(problem,interpretation,var_b);
}
// Must, May and Current queries for pattern queries ContinentInside
private pattern mustInRelation_pattern_queries_ContinentInside(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfContinent_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfContinent_class(problem,interpretation,var_a);
	find mustInRelationinsides_reference_CompositeRegion(problem,interpretation,var_a,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustEquivalent(problem, interpretation, var_virtual0, var_b);
	neg find mayInRelation_pattern_queries_isLake(problem,interpretation,var_b);
	neg find mayInRelation_pattern_queries_isMountain(problem,interpretation,var_b);
	neg find mayInRelation_pattern_queries_isCity(problem,interpretation,var_b);
}
private pattern mayInRelation_pattern_queries_ContinentInside(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfContinent_class(problem,interpretation,var_a);
	// a is exported
	find mayInstanceOfContinent_class(problem,interpretation,var_a);
	find mayInRelationinsides_reference_CompositeRegion(problem,interpretation,var_a,var_virtual0);
	find mayInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_b);
	neg find mustInRelation_pattern_queries_isLake(problem,interpretation,var_b);
	neg find mustInRelation_pattern_queries_isMountain(problem,interpretation,var_b);
	neg find mustInRelation_pattern_queries_isCity(problem,interpretation,var_b);
}
private pattern currentInRelation_pattern_queries_ContinentInside(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfContinent_class(problem,interpretation,var_a);
	// a is exported
	find mustInstanceOfContinent_class(problem,interpretation,var_a);
	find mustInRelationinsides_reference_CompositeRegion(problem,interpretation,var_a,var_virtual0);
	find mustInstanceOfRegion_class(problem,interpretation,var_virtual0);
	find mustEquivalent(problem, interpretation, var_virtual0, var_b);
	neg find currentInRelation_pattern_queries_isLake(problem,interpretation,var_b);
	neg find currentInRelation_pattern_queries_isMountain(problem,interpretation,var_b);
	neg find currentInRelation_pattern_queries_isCity(problem,interpretation,var_b);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationinsides_reference_CompositeRegion(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_queries_IslandInside(problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find mustInRelation_pattern_queries_IslandInside(problem,interpretation,var_a);
}
pattern invalidatedBy_pattern_queries_SeaInside(problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find mustInRelation_pattern_queries_SeaInside(problem,interpretation,var_a);
}
pattern invalidatedBy_pattern_queries_ContinentInside(problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find mustInRelation_pattern_queries_ContinentInside(problem,interpretation,var_a);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_queries_IslandInside(problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find currentInRelation_pattern_queries_IslandInside(problem,interpretation,var_a);
}
pattern unfinishedBy_pattern_queries_SeaInside(problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find currentInRelation_pattern_queries_SeaInside(problem,interpretation,var_a);
}
pattern unfinishedBy_pattern_queries_ContinentInside(problem:LogicProblem, interpretation:PartialInterpretation,
	var_a)
{
	find currentInRelation_pattern_queries_ContinentInside(problem,interpretation,var_a);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeRegion_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLake_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfElementaryRegion_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMountain_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCity_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfContinent_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfIsland_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSea_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSea_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSea_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeRegion_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeRegion_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Lake_class_by_insides_reference_CompositeRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Lake class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"insides reference CompositeRegion");
	find mustInstanceOfCompositeRegion_class(problem,interpretation,container);
	find mayInstanceOfLake_class(problem,interpretation,newObject);
	find mayInRelationinsides_reference_CompositeRegion(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Lake_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Lake class");
	find mayInstanceOfLake_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Mountain_class_by_insides_reference_CompositeRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Mountain class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"insides reference CompositeRegion");
	find mustInstanceOfCompositeRegion_class(problem,interpretation,container);
	find mayInstanceOfMountain_class(problem,interpretation,newObject);
	find mayInRelationinsides_reference_CompositeRegion(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Mountain_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Mountain class");
	find mayInstanceOfMountain_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Sea_class_UndefinedPart_by_insides_reference_CompositeRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Sea class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"insides reference CompositeRegion");
	find mustInstanceOfCompositeRegion_class(problem,interpretation,container);
	find mayInstanceOfSea_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationinsides_reference_CompositeRegion(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Sea_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Sea class UndefinedPart");
	find mayInstanceOfSea_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Continent_class_by_insides_reference_CompositeRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Continent class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"insides reference CompositeRegion");
	find mustInstanceOfCompositeRegion_class(problem,interpretation,container);
	find mayInstanceOfContinent_class(problem,interpretation,newObject);
	find mayInRelationinsides_reference_CompositeRegion(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Continent_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Continent class");
	find mayInstanceOfContinent_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Island_class_by_insides_reference_CompositeRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Island class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"insides reference CompositeRegion");
	find mustInstanceOfCompositeRegion_class(problem,interpretation,container);
	find mayInstanceOfIsland_class(problem,interpretation,newObject);
	find mayInRelationinsides_reference_CompositeRegion(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Island_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Island class");
	find mayInstanceOfIsland_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_City_class_by_insides_reference_CompositeRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"City class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"insides reference CompositeRegion");
	find mustInstanceOfCompositeRegion_class(problem,interpretation,container);
	find mayInstanceOfCity_class(problem,interpretation,newObject);
	find mayInRelationinsides_reference_CompositeRegion(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_City_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"City class");
	find mayInstanceOfCity_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Lake_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLake_class(problem,interpretation,element);
	neg find mustInstanceOfLake_class(problem,interpretation,element);
	neg find mustInstanceOfMountain_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCity_class(problem,interpretation,element);
}
pattern refineTypeTo_Mountain_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMountain_class(problem,interpretation,element);
	neg find mustInstanceOfLake_class(problem,interpretation,element);
	neg find mustInstanceOfMountain_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCity_class(problem,interpretation,element);
}
pattern refineTypeTo_Sea_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSea_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfSea_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfContinent_class(problem,interpretation,element);
	neg find mustInstanceOfIsland_class(problem,interpretation,element);
}
pattern refineTypeTo_Continent_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfContinent_class(problem,interpretation,element);
	neg find mustInstanceOfSea_class(problem,interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfContinent_class(problem,interpretation,element);
	neg find mustInstanceOfIsland_class(problem,interpretation,element);
}
pattern refineTypeTo_Island_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfIsland_class(problem,interpretation,element);
	neg find mustInstanceOfSea_class(problem,interpretation,element);
	neg find mustInstanceOfElementaryRegion_class(problem,interpretation,element);
	neg find mustInstanceOfContinent_class(problem,interpretation,element);
	neg find mustInstanceOfIsland_class(problem,interpretation,element);
}
pattern refineTypeTo_City_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCity_class(problem,interpretation,element);
	neg find mustInstanceOfLake_class(problem,interpretation,element);
	neg find mustInstanceOfMountain_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCity_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_next_reference_Region_and_next_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"next reference Region");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"next reference Region");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRegion_class(problem,interpretation,from);
	find mustInstanceOfRegion_class(problem,interpretation,to);
	find mayInRelationnext_reference_Region(problem,interpretation,from,to);
	neg find mustInRelationnext_reference_Region(problem,interpretation,from,to);
}

